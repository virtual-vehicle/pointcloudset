<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>lidar.frame API documentation</title>
<meta name="description" content="Frame Class …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lidar.frame</code></h1>
</header>
<section id="section-intro">
<p>Frame Class.</p>
<p>For one lidar measurement frame. Typically an automotive lidar records many frames per
second.</p>
<p>One Frame consists mainly of pyntcloud pointcloud (.pointcloud) and a pandas dataframe
(.data) with all the associated data.</p>
<p>Note that the index of the poits is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therfore, a new
Frame object is generated at each processing stage.</p>
<p>All operations have to act on both, pointcloud and data and keep the timestamp.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Frame Class.

For one lidar measurement frame. Typically an automotive lidar records many frames per
second.

One Frame consists mainly of pyntcloud pointcloud (.pointcloud) and a pandas dataframe
(.data) with all the associated data.

Note that the index of the poits is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therfore, a new
Frame object is generated at each processing stage.


All operations have to act on both, pointcloud and data and keep the timestamp.
&#34;&#34;&#34;

import operator
from datetime import datetime
from typing import List

import numpy as np
import open3d as o3d
import pandas as pd
import pyntcloud
import rospy

from .convert import convert
from .plot.frame import plotly_3d, pyntcloud_3d

ops = {
    &#34;&gt;&#34;: operator.gt,
    &#34;&lt;&#34;: operator.lt,
    &#34;&gt;=&#34;: operator.ge,
    &#34;&lt;=&#34;: operator.le,
    &#34;==&#34;: operator.eq,
}


class Frame:
    &#34;One Frame of lidar measurements.&#34;

    def __init__(
        self, data: pd.DataFrame, timestamp: rospy.rostime.Time = rospy.rostime.Time()
    ):
        self.data = data
        &#34;&#34;&#34;All the data, x,y.z and intensity, range and more&#34;&#34;&#34;
        self.timestamp = timestamp
        &#34;&#34;&#34;ROS timestamp&#34;&#34;&#34;
        self.points = pyntcloud.PyntCloud(self.data[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]], mesh=None)
        &#34;&#34;&#34;Pyntcloud object with x,y,z coordinates&#34;&#34;&#34;
        self.measurments = self.data.drop([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;], axis=1)
        &#34;&#34;&#34;Measurments aka. scalar field of values at each point&#34;&#34;&#34;
        self._check_index()

    def __str__(self):
        return f&#34;pointcloud: with {len(self)} points, data:{list(self.data.columns)}, from {self.convert_timestamp()}&#34;

    def __len__(self):
        return len(self.data)

    def describe(self):
        &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
        &#34;&#34;&#34;
        return self.data.describe()

    def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
        &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
        open3d package.

        Returns:
            o3d.open3d_pybind.geometry.PointCloud: the pointcloud
        &#34;&#34;&#34;
        return convert.convert_df2pcd(self.points.points)

    def convert_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

        Returns:
            str: date time string
        &#34;&#34;&#34;
        return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
            &#34;%A, %B %d, %Y %I:%M:%S&#34;
        )

    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
        measruments at each point of the pointcloud.

        Returns:
            bool: `True`` if the lidar frame contains measurment data.
        &#34;&#34;&#34;
        return not self.data.empty

    def distances_to_origin(self) -&gt; np.array:
        &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
        to the origin (0,0,0).

        Returns:
            np.array: List of distances for each point
        &#34;&#34;&#34;
        point_a = np.array((0.0, 0.0, 0.0))
        points = self.points.xyz
        dists = [np.linalg.norm(point_a - point) for point in points]
        return np.array(dists)

    def plot_interactive(
        self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
    ):
        args = locals()
        args.update(kwargs)
        backend = args.pop(&#34;backend&#34;)
        if backend == &#34;pyntcloud&#34;:
            return pyntcloud_3d(self, **kwargs)
        elif backend == &#34;plotly&#34;:
            return plotly_3d(self, color=color, **kwargs)
        else:
            raise ValueError(&#34;wrong backend&#34;)

    def apply_filter(self, boolean_array: np.ndarray):
        &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
        Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

        Args:
            boolean_array (np.ndarray): True where the point should remain.

        Returns:
            Frame: Frame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        new_data = self.data.loc[boolean_array].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def select_by_index(self, index_to_keep: List[int]):
        &#34;&#34;&#34;Generating a new Frame by keeping which are in the same idex
        Usefull for open3d generate index lists. Similar to the the select_by_index
        function of open3d.

        Args:
            index_to_keep (List[int]): List of indices to keep

        Returns:
            Frame: Frame with keeped rows and reindexed data and points
        &#34;&#34;&#34;
        new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were 
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        bool_array = (
            (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
        ).to_numpy()
        return self.apply_filter(bool_array)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.get_open3d_points().cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def remove_radius_outlier(self, nb_points: int, radius: float):
        &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given 
        sphere of a given radius Parameters.
        Args:
            nb_points (int) – Number of points within the radius.
            radius (float) – Radius of the sphere.
        Returns:
            Tuple[open3d.geometry.PointCloud, List[int]] :
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        cl, index_to_keep = pcd.remove_radius_outlier(
            nb_points=nb_points, radius=radius
        )
        return self.select_by_index(index_to_keep)

    def quantile_filter(
        self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
    ):
        &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

        testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

        Args:
            dim (str): column in data, for example &#34;intensity&#34;
            relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
            cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

        Returns:
            Frame: Frame which fullfils the criteria.
        &#34;&#34;&#34;
        cut_value = self.data[dim].quantile(cut_quantile)
        filter_array = ops[relation](self.data[dim], cut_value)
        return self.apply_filter(filter_array.to_numpy())

    def plane_segmentation(
        self, max_dist: float, max_iterations: int, n_inliers_to_stop=None
    ):
        return self.points.add_scalar_field(
            &#34;plane_fit&#34;,
            max_dist=max_dist,
            max_iterations=max_iterations,
            n_inliers_to_stop=n_inliers_to_stop,
        )

    def _check_index(self):
        &#34;&#34;&#34;A private function to check if the index of the self.data is sane.
        &#34;&#34;&#34;
        if len(self) &gt; 0:
            assert self.data.index[0] == 0, &#34;index should start with 0&#34;
            assert self.data.index[-1] + 1 == len(
                self
            ), &#34;index should be as long as the data&#34;
            assert (
                self.data.index.is_monotonic_increasing
            ), &#34;index should be monotonic increasing&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lidar.frame.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>data: pandas.core.frame.DataFrame, timestamp: rospy.rostime.Time = rospy.Time[0])</span>
</code></dt>
<dd>
<div class="desc"><p>One Frame of lidar measurements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame:
    &#34;One Frame of lidar measurements.&#34;

    def __init__(
        self, data: pd.DataFrame, timestamp: rospy.rostime.Time = rospy.rostime.Time()
    ):
        self.data = data
        &#34;&#34;&#34;All the data, x,y.z and intensity, range and more&#34;&#34;&#34;
        self.timestamp = timestamp
        &#34;&#34;&#34;ROS timestamp&#34;&#34;&#34;
        self.points = pyntcloud.PyntCloud(self.data[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]], mesh=None)
        &#34;&#34;&#34;Pyntcloud object with x,y,z coordinates&#34;&#34;&#34;
        self.measurments = self.data.drop([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;], axis=1)
        &#34;&#34;&#34;Measurments aka. scalar field of values at each point&#34;&#34;&#34;
        self._check_index()

    def __str__(self):
        return f&#34;pointcloud: with {len(self)} points, data:{list(self.data.columns)}, from {self.convert_timestamp()}&#34;

    def __len__(self):
        return len(self.data)

    def describe(self):
        &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
        &#34;&#34;&#34;
        return self.data.describe()

    def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
        &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
        open3d package.

        Returns:
            o3d.open3d_pybind.geometry.PointCloud: the pointcloud
        &#34;&#34;&#34;
        return convert.convert_df2pcd(self.points.points)

    def convert_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

        Returns:
            str: date time string
        &#34;&#34;&#34;
        return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
            &#34;%A, %B %d, %Y %I:%M:%S&#34;
        )

    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
        measruments at each point of the pointcloud.

        Returns:
            bool: `True`` if the lidar frame contains measurment data.
        &#34;&#34;&#34;
        return not self.data.empty

    def distances_to_origin(self) -&gt; np.array:
        &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
        to the origin (0,0,0).

        Returns:
            np.array: List of distances for each point
        &#34;&#34;&#34;
        point_a = np.array((0.0, 0.0, 0.0))
        points = self.points.xyz
        dists = [np.linalg.norm(point_a - point) for point in points]
        return np.array(dists)

    def plot_interactive(
        self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
    ):
        args = locals()
        args.update(kwargs)
        backend = args.pop(&#34;backend&#34;)
        if backend == &#34;pyntcloud&#34;:
            return pyntcloud_3d(self, **kwargs)
        elif backend == &#34;plotly&#34;:
            return plotly_3d(self, color=color, **kwargs)
        else:
            raise ValueError(&#34;wrong backend&#34;)

    def apply_filter(self, boolean_array: np.ndarray):
        &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
        Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

        Args:
            boolean_array (np.ndarray): True where the point should remain.

        Returns:
            Frame: Frame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        new_data = self.data.loc[boolean_array].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def select_by_index(self, index_to_keep: List[int]):
        &#34;&#34;&#34;Generating a new Frame by keeping which are in the same idex
        Usefull for open3d generate index lists. Similar to the the select_by_index
        function of open3d.

        Args:
            index_to_keep (List[int]): List of indices to keep

        Returns:
            Frame: Frame with keeped rows and reindexed data and points
        &#34;&#34;&#34;
        new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were 
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        bool_array = (
            (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
        ).to_numpy()
        return self.apply_filter(bool_array)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.get_open3d_points().cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def remove_radius_outlier(self, nb_points: int, radius: float):
        &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given 
        sphere of a given radius Parameters.
        Args:
            nb_points (int) – Number of points within the radius.
            radius (float) – Radius of the sphere.
        Returns:
            Tuple[open3d.geometry.PointCloud, List[int]] :
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        cl, index_to_keep = pcd.remove_radius_outlier(
            nb_points=nb_points, radius=radius
        )
        return self.select_by_index(index_to_keep)

    def quantile_filter(
        self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
    ):
        &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

        testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

        Args:
            dim (str): column in data, for example &#34;intensity&#34;
            relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
            cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

        Returns:
            Frame: Frame which fullfils the criteria.
        &#34;&#34;&#34;
        cut_value = self.data[dim].quantile(cut_quantile)
        filter_array = ops[relation](self.data[dim], cut_value)
        return self.apply_filter(filter_array.to_numpy())

    def plane_segmentation(
        self, max_dist: float, max_iterations: int, n_inliers_to_stop=None
    ):
        return self.points.add_scalar_field(
            &#34;plane_fit&#34;,
            max_dist=max_dist,
            max_iterations=max_iterations,
            n_inliers_to_stop=n_inliers_to_stop,
        )

    def _check_index(self):
        &#34;&#34;&#34;A private function to check if the index of the self.data is sane.
        &#34;&#34;&#34;
        if len(self) &gt; 0:
            assert self.data.index[0] == 0, &#34;index should start with 0&#34;
            assert self.data.index[-1] + 1 == len(
                self
            ), &#34;index should be as long as the data&#34;
            assert (
                self.data.index.is_monotonic_increasing
            ), &#34;index should be monotonic increasing&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="lidar.frame.Frame.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>All the data, x,y.z and intensity, range and more</p></div>
</dd>
<dt id="lidar.frame.Frame.measurments"><code class="name">var <span class="ident">measurments</span></code></dt>
<dd>
<div class="desc"><p>Measurments aka. scalar field of values at each point</p></div>
</dd>
<dt id="lidar.frame.Frame.points"><code class="name">var <span class="ident">points</span></code></dt>
<dd>
<div class="desc"><p>Pyntcloud object with x,y,z coordinates</p></div>
</dd>
<dt id="lidar.frame.Frame.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<div class="desc"><p>ROS timestamp</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lidar.frame.Frame.apply_filter"><code class="name flex">
<span>def <span class="ident">apply_filter</span></span>(<span>self, boolean_array: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Generating a new Frame by removing points where filter is False.
Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boolean_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>True where the point should remain.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame with filterd rows and reindexed data and points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_filter(self, boolean_array: np.ndarray):
    &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
    Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

    Args:
        boolean_array (np.ndarray): True where the point should remain.

    Returns:
        Frame: Frame with filterd rows and reindexed data and points.
    &#34;&#34;&#34;
    new_data = self.data.loc[boolean_array].reset_index(drop=True)
    return Frame(new_data, timestamp=self.timestamp)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.convert_timestamp"><code class="name flex">
<span>def <span class="ident">convert_timestamp</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ROS timestamp to human readable date and time.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>date time string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_timestamp(self) -&gt; str:
    &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

    Returns:
        str: date time string
    &#34;&#34;&#34;
    return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
        &#34;%A, %B %d, %Y %I:%M:%S&#34;
    )</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate descriptive statistics based on .data.describe().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
    &#34;&#34;&#34;
    return self.data.describe()</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.distances_to_origin"><code class="name flex">
<span>def <span class="ident">distances_to_origin</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>For each point in the pointcloud calculate the euclidian distance
to the origin (0,0,0).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>List of distances for each point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distances_to_origin(self) -&gt; np.array:
    &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
    to the origin (0,0,0).

    Returns:
        np.array: List of distances for each point
    &#34;&#34;&#34;
    point_a = np.array((0.0, 0.0, 0.0))
    points = self.points.xyz
    dists = [np.linalg.norm(point_a - point) for point in points]
    return np.array(dists)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.get_cluster"><code class="name flex">
<span>def <span class="ident">get_cluster</span></span>(<span>self, eps: float, min_points: int) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get the clusters based on open3D cluster_dbscan. Process futher with
take_cluster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Density parameter that is used to find neighbouring points.</dd>
<dt><strong><code>min_points</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum number of points to form a cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Dataframe with list of clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
        take_cluster.

    Args:
        eps (float): Density parameter that is used to find neighbouring points.
        min_points (int): Minimum number of points to form a cluster.

    Returns:
        pd.DataFrame: Dataframe with list of clusters.
    &#34;&#34;&#34;
    labels = np.array(
        self.get_open3d_points().cluster_dbscan(
            eps=eps, min_points=min_points, print_progress=False
        )
    )
    labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
    return labels_df</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.get_open3d_points"><code class="name flex">
<span>def <span class="ident">get_open3d_points</span></span>(<span>self) ‑> open3d.open3d_pybind.geometry.PointCloud</span>
</code></dt>
<dd>
<div class="desc"><p>Extract points as open3D PointCloud object. Needed for processing with the
open3d package.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>o3d.open3d_pybind.geometry.PointCloud</code></dt>
<dd>the pointcloud</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
    &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
    open3d package.

    Returns:
        o3d.open3d_pybind.geometry.PointCloud: the pointcloud
    &#34;&#34;&#34;
    return convert.convert_df2pcd(self.points.points)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.has_data"><code class="name flex">
<span>def <span class="ident">has_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if lidar frame has data. Data here means point coordinates and
measruments at each point of the pointcloud.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>`True`` if the lidar frame contains measurment data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_data(self) -&gt; bool:
    &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
    measruments at each point of the pointcloud.

    Returns:
        bool: `True`` if the lidar frame contains measurment data.
    &#34;&#34;&#34;
    return not self.data.empty</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.limit"><code class="name flex">
<span>def <span class="ident">limit</span></span>(<span>self, dim: str, minvalue: float, maxvalue: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Limit the range of certain values in lidar Frame. Can be chained together.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>str</code></dt>
<dd>dimension to limit, any column in data not just x, y, or z</dd>
<dt><strong><code>minvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>min value to limit. (greater equal)</dd>
<dt><strong><code>maxvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>max value to limit. (smaller equal)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>limited frame, were columns which did not match the criteria were </dd>
</dl>
<p>dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
    &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

    Args:
        dim (str): dimension to limit, any column in data not just x, y, or z
        minvalue (float): min value to limit. (greater equal)
        maxvalue (float): max value to limit. (smaller equal)
    Returns:
        Frame: limited frame, were columns which did not match the criteria were 
        dropped.
    &#34;&#34;&#34;
    if maxvalue &lt; minvalue:
        raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
    bool_array = (
        (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
    ).to_numpy()
    return self.apply_filter(bool_array)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plane_segmentation"><code class="name flex">
<span>def <span class="ident">plane_segmentation</span></span>(<span>self, max_dist: float, max_iterations: int, n_inliers_to_stop=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane_segmentation(
    self, max_dist: float, max_iterations: int, n_inliers_to_stop=None
):
    return self.points.add_scalar_field(
        &#34;plane_fit&#34;,
        max_dist=max_dist,
        max_iterations=max_iterations,
        n_inliers_to_stop=n_inliers_to_stop,
    )</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plot_interactive"><code class="name flex">
<span>def <span class="ident">plot_interactive</span></span>(<span>self, backend: str = 'plotly', color: str = 'intensity', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_interactive(
    self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
):
    args = locals()
    args.update(kwargs)
    backend = args.pop(&#34;backend&#34;)
    if backend == &#34;pyntcloud&#34;:
        return pyntcloud_3d(self, **kwargs)
    elif backend == &#34;plotly&#34;:
        return plotly_3d(self, color=color, **kwargs)
    else:
        raise ValueError(&#34;wrong backend&#34;)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.quantile_filter"><code class="name flex">
<span>def <span class="ident">quantile_filter</span></span>(<span>self, dim: str, relation: str = &#x27;&gt;=&#x27;, cut_quantile: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Filtering based on quantile values of dimension dim of the data.</p>
<p>testframe.quantile_filter("intensity","==",0.5)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>str</code></dt>
<dd>column in data, for example "intensity"</dd>
<dt><strong><code>relation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Any operator as string. Defaults to "&gt;=".</dd>
<dt><strong><code>cut_quantile</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Qunatile to compare to. Defaults to 0.5.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame which fullfils the criteria.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quantile_filter(
    self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
):
    &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

    testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

    Args:
        dim (str): column in data, for example &#34;intensity&#34;
        relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
        cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

    Returns:
        Frame: Frame which fullfils the criteria.
    &#34;&#34;&#34;
    cut_value = self.data[dim].quantile(cut_quantile)
    filter_array = ops[relation](self.data[dim], cut_value)
    return self.apply_filter(filter_array.to_numpy())</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.remove_radius_outlier"><code class="name flex">
<span>def <span class="ident">remove_radius_outlier</span></span>(<span>self, nb_points: int, radius: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove points that have less than nb_points in a given
sphere of a given radius Parameters.</p>
<h2 id="args">Args</h2>
<p>nb_points (int) – Number of points within the radius.
radius (float) – Radius of the sphere.</p>
<h2 id="returns">Returns</h2>
<p>Tuple[open3d.geometry.PointCloud, List[int]] :</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_radius_outlier(self, nb_points: int, radius: float):
    &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given 
    sphere of a given radius Parameters.
    Args:
        nb_points (int) – Number of points within the radius.
        radius (float) – Radius of the sphere.
    Returns:
        Tuple[open3d.geometry.PointCloud, List[int]] :
    &#34;&#34;&#34;
    pcd = self.get_open3d_points()
    cl, index_to_keep = pcd.remove_radius_outlier(
        nb_points=nb_points, radius=radius
    )
    return self.select_by_index(index_to_keep)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.select_by_index"><code class="name flex">
<span>def <span class="ident">select_by_index</span></span>(<span>self, index_to_keep: List[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Generating a new Frame by keeping which are in the same idex
Usefull for open3d generate index lists. Similar to the the select_by_index
function of open3d.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index_to_keep</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>List of indices to keep</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame with keeped rows and reindexed data and points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_by_index(self, index_to_keep: List[int]):
    &#34;&#34;&#34;Generating a new Frame by keeping which are in the same idex
    Usefull for open3d generate index lists. Similar to the the select_by_index
    function of open3d.

    Args:
        index_to_keep (List[int]): List of indices to keep

    Returns:
        Frame: Frame with keeped rows and reindexed data and points
    &#34;&#34;&#34;
    new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
    return Frame(new_data, timestamp=self.timestamp)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.take_cluster"><code class="name flex">
<span>def <span class="ident">take_cluster</span></span>(<span>self, cluster_number: int, cluster_labels: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes only the points belonging to the cluster_number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cluster_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Cluster id to keep.</dd>
<dt><strong><code>cluster_labels</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>clusters generated with get_cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>with cluster of ID cluster_number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
    &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

    Args:
        cluster_number (int): Cluster id to keep.
        cluster_labels (pd.DataFrame): clusters generated with get_cluster.

    Returns:
        Frame: with cluster of ID cluster_number.
    &#34;&#34;&#34;
    bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
    return self.apply_filter(bool_array)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lidar" href="index.html">lidar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></h4>
<ul class="">
<li><code><a title="lidar.frame.Frame.apply_filter" href="#lidar.frame.Frame.apply_filter">apply_filter</a></code></li>
<li><code><a title="lidar.frame.Frame.convert_timestamp" href="#lidar.frame.Frame.convert_timestamp">convert_timestamp</a></code></li>
<li><code><a title="lidar.frame.Frame.data" href="#lidar.frame.Frame.data">data</a></code></li>
<li><code><a title="lidar.frame.Frame.describe" href="#lidar.frame.Frame.describe">describe</a></code></li>
<li><code><a title="lidar.frame.Frame.distances_to_origin" href="#lidar.frame.Frame.distances_to_origin">distances_to_origin</a></code></li>
<li><code><a title="lidar.frame.Frame.get_cluster" href="#lidar.frame.Frame.get_cluster">get_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.get_open3d_points" href="#lidar.frame.Frame.get_open3d_points">get_open3d_points</a></code></li>
<li><code><a title="lidar.frame.Frame.has_data" href="#lidar.frame.Frame.has_data">has_data</a></code></li>
<li><code><a title="lidar.frame.Frame.limit" href="#lidar.frame.Frame.limit">limit</a></code></li>
<li><code><a title="lidar.frame.Frame.measurments" href="#lidar.frame.Frame.measurments">measurments</a></code></li>
<li><code><a title="lidar.frame.Frame.plane_segmentation" href="#lidar.frame.Frame.plane_segmentation">plane_segmentation</a></code></li>
<li><code><a title="lidar.frame.Frame.plot_interactive" href="#lidar.frame.Frame.plot_interactive">plot_interactive</a></code></li>
<li><code><a title="lidar.frame.Frame.points" href="#lidar.frame.Frame.points">points</a></code></li>
<li><code><a title="lidar.frame.Frame.quantile_filter" href="#lidar.frame.Frame.quantile_filter">quantile_filter</a></code></li>
<li><code><a title="lidar.frame.Frame.remove_radius_outlier" href="#lidar.frame.Frame.remove_radius_outlier">remove_radius_outlier</a></code></li>
<li><code><a title="lidar.frame.Frame.select_by_index" href="#lidar.frame.Frame.select_by_index">select_by_index</a></code></li>
<li><code><a title="lidar.frame.Frame.take_cluster" href="#lidar.frame.Frame.take_cluster">take_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.timestamp" href="#lidar.frame.Frame.timestamp">timestamp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>