<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>lidar.frame API documentation</title>
<meta name="description" content="Frame Class …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lidar.frame</code></h1>
</header>
<section id="section-intro">
<h1 id="frame-class">Frame Class.</h1>
<p>For one lidar measurement frame. Typically an automotive lidar records many frames per
second.</p>
<p>One Frame consists mainly of pyntcloud pointcloud (.points) and a pandas dataframe
(.data) with all the associated data.</p>
<p>Note that the index of the points is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therefore, a new
Frame object is generated at each processing stage.</p>
<h2 id="developer-notes">Developer notes:</h2>
<ul>
<li>All operations have to act on both, pointcloud and data and keep the timestamp.</li>
<li>All processing methods need to return another Frame.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Frame Class.

For one lidar measurement frame. Typically an automotive lidar records many frames per
second.

One Frame consists mainly of pyntcloud pointcloud (.points) and a pandas dataframe
(.data) with all the associated data.

Note that the index of the points is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therefore, a new
Frame object is generated at each processing stage.

## Developer notes:
* All operations have to act on both, pointcloud and data and keep the timestamp.
* All processing methods need to return another Frame.
&#34;&#34;&#34;
from __future__ import annotations

import datetime
import warnings
from pathlib import Path
from typing import List, Union

import numpy as np
import open3d as o3d
import pandas as pd
import plotly
import plotly.express as px
import pyntcloud

from lidar.diff import ALL_DIFFS
from lidar.filter import ALL_FILTERS
from lidar.frame_core import FrameCore
from lidar.io import (
    FRAME_FROM_FILE,
    FRAME_FROM_INSTANCE,
    FRAME_TO_FILE,
    FRAME_TO_INSTANCE,
)
from lidar.plot.frame import plot_overlay


def is_documented_by(original):
    &#34;&#34;&#34;A decorator to get the docstring from anoter function.&#34;&#34;&#34;

    def wrapper(target):
        target.__doc__ = original.__doc__
        return target

    return wrapper


class Frame(FrameCore):
    &#34;&#34;&#34;One lidar frame.&#34;&#34;&#34;

    @classmethod
    def from_file(cls, file_path: Path, **kwargs):
        &#34;&#34;&#34;Extract data from file and construct a Frame with it. Uses Pynthcloud as
        backend.

        Args:
            file_path (Path): pathlib Path of file to read

        Raises:
            ValueError: For unsupported files

        Returns:
            Frame: lidar frame with timestamp last modified.
        &#34;&#34;&#34;
        if not isinstance(file_path, Path):
            raise TypeError(&#34;Expectinga Path object for file_path&#34;)
        ext = file_path.suffix[1:].upper()
        if ext not in FRAME_FROM_FILE:
            raise ValueError(
                &#34;Unsupported file format; supported formats are: {}&#34;.format(
                    list(FRAME_FROM_FILE)
                )
            )
        else:
            file_path_str = file_path.as_posix()
            timestamp = datetime.datetime.utcfromtimestamp(file_path.stat().st_mtime)
            pyntcloud_in = pyntcloud.PyntCloud.from_file(file_path_str, **kwargs)
            return cls(
                data=pyntcloud_in.points, orig_file=file_path_str, timestamp=timestamp
            )

    def to_file(self, file_path: Path = Path(), **kwargs) -&gt; None:
        &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
        Currently not all attributes of a frame are saved so some information is lost when
        using this function.

        Args:
            file_path (Path, optional): Destination. Defaults to the folder of
            the bag file and csv with the timestamp of the frame.
        &#34;&#34;&#34;
        ext = file_path.suffix[1:].upper()
        if ext not in FRAME_TO_FILE:
            raise ValueError(
                &#34;Unsupported file format; supported formats are: {}&#34;.format(
                    list(FRAME_TO_FILE)
                )
            )

        orig_file_name = Path(self.orig_file).stem
        if file_path == Path():
            # defaulting to csv file
            filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
            destination_folder = Path(self.orig_file).parent.joinpath(filename)
        else:
            destination_folder = file_path

        kwargs[&#34;file_path&#34;] = destination_folder
        kwargs[&#34;frame&#34;] = self

        FRAME_TO_FILE[ext](**kwargs)

    @classmethod
    def from_instance(
        cls,
        library: str,
        instance: Union[
            pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
        ],
        **kwargs,
    ) -&gt; Frame:
        &#34;&#34;&#34;Converts a libaries instance to a lidar Frame.

        Args:
            library (str): name of the libary
            instance (Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]): [description]

        Raises:
            ValueError: If instance is not supported.

        Returns:
            Frame: derived from the instance
        &#34;&#34;&#34;
        library = library.upper()
        if library not in FRAME_FROM_INSTANCE:
            raise ValueError(
                &#34;Unsupported library; supported libraries are: {}&#34;.format(
                    list(FRAME_FROM_INSTANCE)
                )
            )
        else:
            return cls(**FRAME_FROM_INSTANCE[library](instance, **kwargs))

    def to_instance(
        self, library: str, **kwargs
    ) -&gt; Union[
        pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
    ]:
        &#34;&#34;&#34;Convert Frame to another librarie instance.

        Args:
            library (str): name of the libary

        Raises:
            ValueError: If libary is not suppored

        Returns:
            Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]: The derived instance
        &#34;&#34;&#34;
        library = library.upper()
        if library not in FRAME_TO_INSTANCE:
            raise ValueError(
                &#34;Unsupported library; supported libraries are: {}&#34;.format(
                    list(FRAME_TO_INSTANCE)
                )
            )

        return FRAME_TO_INSTANCE[library](self, **kwargs)

    def plot(
        self,
        color: Union[None, str] = None,
        overlay: dict = {},
        point_size: float = 2,
        prepend_id: str = &#34;&#34;,
        hover_data: List[str] = [],
        **kwargs,
    ) -&gt; plotly.graph_objs._figure.Figure:
        &#34;&#34;&#34;Plot a Frame as a 3D scatter plot with plotly. It handles plots of single
        frames and overlay with other objects, such as other frames from clustering or
        planes from plane segmentation.

        You can also pass arguments to the plotly express function scatter_3D.

        Args:
            frame (Frame): the frame to plot
            color (str or None): Which column to plot. For example &#34;intensity&#34;
            overlay (dict, optional): Dict with of rames to overlay
                {&#34;Cluster 1&#34;: cluster1,&#34;plan1 1&#34;: plane_model}
            point_size (float, optional): Size of each point. Defaults to 2.
            prepend_id (str, optional): string before point id to display in hover
            hover data (list, optional): data columns to display in hover. Default is
                all of them.

        Raises:
            ValueError: if the color column name is not in the data

        Returns:
            Plotly plot: The interactive plotly plot, best used inside a jupyter
            notebook.
        &#34;&#34;&#34;
        if color is not None and color not in self.data.columns:
            raise ValueError(f&#34;choose any of {list(self.data.columns)} or None&#34;)

        ids = [prepend_id + &#34;id=&#34; + str(i) for i in range(0, self.data.shape[0])]

        if hover_data == []:
            hover_data = self.data.columns

        if not all([x in self.data.columns for x in hover_data]):
            raise ValueError(f&#34;choose a list of {list(self.data.columns)} or []&#34;)

        fig = px.scatter_3d(
            self.data,
            x=&#34;x&#34;,
            y=&#34;y&#34;,
            z=&#34;z&#34;,
            color=color,
            hover_name=ids,
            hover_data=hover_data,
            title=self.timestamp_str,
            **kwargs,
        )
        fig.update_traces(
            marker=dict(size=point_size, line=dict(width=0)),
            selector=dict(mode=&#34;markers&#34;),
        )

        if len(overlay) &gt; 0:
            fig = plot_overlay(fig, self, overlay)

        fig.update_layout(
            scene_aspectmode=&#34;data&#34;,
        )
        return fig

    def diff(
        self, name: str, target: Union[None, Frame, np.ndarray] = None, **kwargs
    ) -&gt; Frame:
        &#34;&#34;&#34;Calculate differences and distances to the origin, plane, point and frame.

        Args:
            name (str): &#34;orgin&#34;, &#34;plane&#34;, &#34;frame&#34;, &#34;point&#34;
            target (Union[None, Frame, np.ndarray], optional): [description]. Defaults to None,

        Raises:
            ValueError: If name is not supported.

        Returns:
            Frame: New frame with added column of the differences
        &#34;&#34;&#34;
        if name in ALL_DIFFS:
            ALL_DIFFS[name](frame=self, target=target, **kwargs)
            return self
        else:
            raise ValueError(&#34;Unsupported diff. Check docstring&#34;)

    def filter(self, name: str, *args, **kwargs) -&gt; Frame:
        name = name.upper()
        if name in ALL_FILTERS:
            return ALL_FILTERS[name](self, *args, **kwargs)
        else:
            raise ValueError(&#34;Unsupported filter. Check docstring&#34;)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float) -&gt; Frame:
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Example:

        testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        return self.filter(&#34;value&#34;, dim, &#34;&gt;=&#34;, minvalue).filter(
            &#34;value&#34;, dim, &#34;&lt;=&#34;, maxvalue
        )

    def apply_filter(self, filter_result: Union[np.ndarray, List[int]]) -&gt; Frame:
        &#34;&#34;&#34;Generating a new Frame by removing points where filter

        Args:
            filter_result (Union[np.ndarray, List[int]]): Filter result

        Raises:
            TypeError: If the filter_result has the wrong type

        Returns:
            Frame: rame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        if isinstance(filter_result, np.ndarray):
            # dataframe and pyntcloud based filters
            new_data = self.data.loc[filter_result].reset_index(drop=True)
        elif isinstance(filter_result, list):
            # from open3d filters
            new_data = self.data.iloc[filter_result].reset_index(drop=True)
        else:
            raise TypeError(
                &#34;Wrong filter_result expeciting array with boolean values or list of intices&#34;
            )
        return Frame(new_data, timestamp=self.timestamp)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process further with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.to_instance(&#34;open3d&#34;).cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame) -&gt; Frame:
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def plane_segmentation(
        self,
        distance_threshold: float,
        ransac_n: int,
        num_iterations: int,
        return_plane_model: bool = False,
    ) -&gt; Union[Frame, dict]:
        &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
        Based on open3D plane segmentation.

        Args:
            distance_threshold (float): Max distance a point can be from the plane
                        model, and still be considered an inlier.
            ransac_n (int):  Number of initial points to be considered inliers in
                        each iteration.
            num_iterations (int): Number of iterations.
            return_plane_model (bool, optional): Return also plane model parameters.
                        Defaults to False.

        Returns:
            Frame or dict: Frame with inliers or a dict of Frame with inliers and the
            plane parameters.
        &#34;&#34;&#34;
        pcd = self.to_instance(&#34;open3d&#34;)
        plane_model, inliers = pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations,
        )
        if len(self) &gt; 200:
            warnings.warn(
                &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
                is high. Try to reduce the area of interesst before using
                plane_segmentation. Caused by open3D.&#34;&#34;&#34;
            )
        inlier_Frame = self.apply_filter(inliers)
        if return_plane_model:
            return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
        else:
            return inlier_Frame</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lidar.frame.is_documented_by"><code class="name flex">
<span>def <span class="ident">is_documented_by</span></span>(<span>original)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator to get the docstring from anoter function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_documented_by(original):
    &#34;&#34;&#34;A decorator to get the docstring from anoter function.&#34;&#34;&#34;

    def wrapper(target):
        target.__doc__ = original.__doc__
        return target

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lidar.frame.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>data: pd.DataFrame, orig_file: str = '', timestamp: datetime = datetime.datetime(2021, 3, 22, 7, 31, 9, 515650))</span>
</code></dt>
<dd>
<div class="desc"><p>One lidar frame.</p>
<p>One Frame of lidar measurements.</p>
<p>Example:
testbag = Path().cwd().parent.joinpath("tests/testdata/test.bag")
testset = lidar.Dataset(testbag,topic="/os1_cloud_node/points",keep_zeros=False)
testframe = testset[0]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame(FrameCore):
    &#34;&#34;&#34;One lidar frame.&#34;&#34;&#34;

    @classmethod
    def from_file(cls, file_path: Path, **kwargs):
        &#34;&#34;&#34;Extract data from file and construct a Frame with it. Uses Pynthcloud as
        backend.

        Args:
            file_path (Path): pathlib Path of file to read

        Raises:
            ValueError: For unsupported files

        Returns:
            Frame: lidar frame with timestamp last modified.
        &#34;&#34;&#34;
        if not isinstance(file_path, Path):
            raise TypeError(&#34;Expectinga Path object for file_path&#34;)
        ext = file_path.suffix[1:].upper()
        if ext not in FRAME_FROM_FILE:
            raise ValueError(
                &#34;Unsupported file format; supported formats are: {}&#34;.format(
                    list(FRAME_FROM_FILE)
                )
            )
        else:
            file_path_str = file_path.as_posix()
            timestamp = datetime.datetime.utcfromtimestamp(file_path.stat().st_mtime)
            pyntcloud_in = pyntcloud.PyntCloud.from_file(file_path_str, **kwargs)
            return cls(
                data=pyntcloud_in.points, orig_file=file_path_str, timestamp=timestamp
            )

    def to_file(self, file_path: Path = Path(), **kwargs) -&gt; None:
        &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
        Currently not all attributes of a frame are saved so some information is lost when
        using this function.

        Args:
            file_path (Path, optional): Destination. Defaults to the folder of
            the bag file and csv with the timestamp of the frame.
        &#34;&#34;&#34;
        ext = file_path.suffix[1:].upper()
        if ext not in FRAME_TO_FILE:
            raise ValueError(
                &#34;Unsupported file format; supported formats are: {}&#34;.format(
                    list(FRAME_TO_FILE)
                )
            )

        orig_file_name = Path(self.orig_file).stem
        if file_path == Path():
            # defaulting to csv file
            filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
            destination_folder = Path(self.orig_file).parent.joinpath(filename)
        else:
            destination_folder = file_path

        kwargs[&#34;file_path&#34;] = destination_folder
        kwargs[&#34;frame&#34;] = self

        FRAME_TO_FILE[ext](**kwargs)

    @classmethod
    def from_instance(
        cls,
        library: str,
        instance: Union[
            pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
        ],
        **kwargs,
    ) -&gt; Frame:
        &#34;&#34;&#34;Converts a libaries instance to a lidar Frame.

        Args:
            library (str): name of the libary
            instance (Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]): [description]

        Raises:
            ValueError: If instance is not supported.

        Returns:
            Frame: derived from the instance
        &#34;&#34;&#34;
        library = library.upper()
        if library not in FRAME_FROM_INSTANCE:
            raise ValueError(
                &#34;Unsupported library; supported libraries are: {}&#34;.format(
                    list(FRAME_FROM_INSTANCE)
                )
            )
        else:
            return cls(**FRAME_FROM_INSTANCE[library](instance, **kwargs))

    def to_instance(
        self, library: str, **kwargs
    ) -&gt; Union[
        pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
    ]:
        &#34;&#34;&#34;Convert Frame to another librarie instance.

        Args:
            library (str): name of the libary

        Raises:
            ValueError: If libary is not suppored

        Returns:
            Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]: The derived instance
        &#34;&#34;&#34;
        library = library.upper()
        if library not in FRAME_TO_INSTANCE:
            raise ValueError(
                &#34;Unsupported library; supported libraries are: {}&#34;.format(
                    list(FRAME_TO_INSTANCE)
                )
            )

        return FRAME_TO_INSTANCE[library](self, **kwargs)

    def plot(
        self,
        color: Union[None, str] = None,
        overlay: dict = {},
        point_size: float = 2,
        prepend_id: str = &#34;&#34;,
        hover_data: List[str] = [],
        **kwargs,
    ) -&gt; plotly.graph_objs._figure.Figure:
        &#34;&#34;&#34;Plot a Frame as a 3D scatter plot with plotly. It handles plots of single
        frames and overlay with other objects, such as other frames from clustering or
        planes from plane segmentation.

        You can also pass arguments to the plotly express function scatter_3D.

        Args:
            frame (Frame): the frame to plot
            color (str or None): Which column to plot. For example &#34;intensity&#34;
            overlay (dict, optional): Dict with of rames to overlay
                {&#34;Cluster 1&#34;: cluster1,&#34;plan1 1&#34;: plane_model}
            point_size (float, optional): Size of each point. Defaults to 2.
            prepend_id (str, optional): string before point id to display in hover
            hover data (list, optional): data columns to display in hover. Default is
                all of them.

        Raises:
            ValueError: if the color column name is not in the data

        Returns:
            Plotly plot: The interactive plotly plot, best used inside a jupyter
            notebook.
        &#34;&#34;&#34;
        if color is not None and color not in self.data.columns:
            raise ValueError(f&#34;choose any of {list(self.data.columns)} or None&#34;)

        ids = [prepend_id + &#34;id=&#34; + str(i) for i in range(0, self.data.shape[0])]

        if hover_data == []:
            hover_data = self.data.columns

        if not all([x in self.data.columns for x in hover_data]):
            raise ValueError(f&#34;choose a list of {list(self.data.columns)} or []&#34;)

        fig = px.scatter_3d(
            self.data,
            x=&#34;x&#34;,
            y=&#34;y&#34;,
            z=&#34;z&#34;,
            color=color,
            hover_name=ids,
            hover_data=hover_data,
            title=self.timestamp_str,
            **kwargs,
        )
        fig.update_traces(
            marker=dict(size=point_size, line=dict(width=0)),
            selector=dict(mode=&#34;markers&#34;),
        )

        if len(overlay) &gt; 0:
            fig = plot_overlay(fig, self, overlay)

        fig.update_layout(
            scene_aspectmode=&#34;data&#34;,
        )
        return fig

    def diff(
        self, name: str, target: Union[None, Frame, np.ndarray] = None, **kwargs
    ) -&gt; Frame:
        &#34;&#34;&#34;Calculate differences and distances to the origin, plane, point and frame.

        Args:
            name (str): &#34;orgin&#34;, &#34;plane&#34;, &#34;frame&#34;, &#34;point&#34;
            target (Union[None, Frame, np.ndarray], optional): [description]. Defaults to None,

        Raises:
            ValueError: If name is not supported.

        Returns:
            Frame: New frame with added column of the differences
        &#34;&#34;&#34;
        if name in ALL_DIFFS:
            ALL_DIFFS[name](frame=self, target=target, **kwargs)
            return self
        else:
            raise ValueError(&#34;Unsupported diff. Check docstring&#34;)

    def filter(self, name: str, *args, **kwargs) -&gt; Frame:
        name = name.upper()
        if name in ALL_FILTERS:
            return ALL_FILTERS[name](self, *args, **kwargs)
        else:
            raise ValueError(&#34;Unsupported filter. Check docstring&#34;)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float) -&gt; Frame:
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Example:

        testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        return self.filter(&#34;value&#34;, dim, &#34;&gt;=&#34;, minvalue).filter(
            &#34;value&#34;, dim, &#34;&lt;=&#34;, maxvalue
        )

    def apply_filter(self, filter_result: Union[np.ndarray, List[int]]) -&gt; Frame:
        &#34;&#34;&#34;Generating a new Frame by removing points where filter

        Args:
            filter_result (Union[np.ndarray, List[int]]): Filter result

        Raises:
            TypeError: If the filter_result has the wrong type

        Returns:
            Frame: rame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        if isinstance(filter_result, np.ndarray):
            # dataframe and pyntcloud based filters
            new_data = self.data.loc[filter_result].reset_index(drop=True)
        elif isinstance(filter_result, list):
            # from open3d filters
            new_data = self.data.iloc[filter_result].reset_index(drop=True)
        else:
            raise TypeError(
                &#34;Wrong filter_result expeciting array with boolean values or list of intices&#34;
            )
        return Frame(new_data, timestamp=self.timestamp)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process further with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.to_instance(&#34;open3d&#34;).cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame) -&gt; Frame:
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def plane_segmentation(
        self,
        distance_threshold: float,
        ransac_n: int,
        num_iterations: int,
        return_plane_model: bool = False,
    ) -&gt; Union[Frame, dict]:
        &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
        Based on open3D plane segmentation.

        Args:
            distance_threshold (float): Max distance a point can be from the plane
                        model, and still be considered an inlier.
            ransac_n (int):  Number of initial points to be considered inliers in
                        each iteration.
            num_iterations (int): Number of iterations.
            return_plane_model (bool, optional): Return also plane model parameters.
                        Defaults to False.

        Returns:
            Frame or dict: Frame with inliers or a dict of Frame with inliers and the
            plane parameters.
        &#34;&#34;&#34;
        pcd = self.to_instance(&#34;open3d&#34;)
        plane_model, inliers = pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations,
        )
        if len(self) &gt; 200:
            warnings.warn(
                &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
                is high. Try to reduce the area of interesst before using
                plane_segmentation. Caused by open3D.&#34;&#34;&#34;
            )
        inlier_Frame = self.apply_filter(inliers)
        if return_plane_model:
            return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
        else:
            return inlier_Frame</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lidar.frame_core.FrameCore" href="frame_core.html#lidar.frame_core.FrameCore">FrameCore</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="lidar.frame.Frame.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>file_path: Path, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract data from file and construct a Frame with it. Uses Pynthcloud as
backend.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>Path</code></dt>
<dd>pathlib Path of file to read</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>For unsupported files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>lidar frame with timestamp last modified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, file_path: Path, **kwargs):
    &#34;&#34;&#34;Extract data from file and construct a Frame with it. Uses Pynthcloud as
    backend.

    Args:
        file_path (Path): pathlib Path of file to read

    Raises:
        ValueError: For unsupported files

    Returns:
        Frame: lidar frame with timestamp last modified.
    &#34;&#34;&#34;
    if not isinstance(file_path, Path):
        raise TypeError(&#34;Expectinga Path object for file_path&#34;)
    ext = file_path.suffix[1:].upper()
    if ext not in FRAME_FROM_FILE:
        raise ValueError(
            &#34;Unsupported file format; supported formats are: {}&#34;.format(
                list(FRAME_FROM_FILE)
            )
        )
    else:
        file_path_str = file_path.as_posix()
        timestamp = datetime.datetime.utcfromtimestamp(file_path.stat().st_mtime)
        pyntcloud_in = pyntcloud.PyntCloud.from_file(file_path_str, **kwargs)
        return cls(
            data=pyntcloud_in.points, orig_file=file_path_str, timestamp=timestamp
        )</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.from_instance"><code class="name flex">
<span>def <span class="ident">from_instance</span></span>(<span>library: str, instance: Union[pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud], **kwargs) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a libaries instance to a lidar Frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>library</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the libary</dd>
<dt><strong><code>instance</code></strong> :&ensp;<code>Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If instance is not supported.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>derived from the instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_instance(
    cls,
    library: str,
    instance: Union[
        pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
    ],
    **kwargs,
) -&gt; Frame:
    &#34;&#34;&#34;Converts a libaries instance to a lidar Frame.

    Args:
        library (str): name of the libary
        instance (Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]): [description]

    Raises:
        ValueError: If instance is not supported.

    Returns:
        Frame: derived from the instance
    &#34;&#34;&#34;
    library = library.upper()
    if library not in FRAME_FROM_INSTANCE:
        raise ValueError(
            &#34;Unsupported library; supported libraries are: {}&#34;.format(
                list(FRAME_FROM_INSTANCE)
            )
        )
    else:
        return cls(**FRAME_FROM_INSTANCE[library](instance, **kwargs))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lidar.frame.Frame.apply_filter"><code class="name flex">
<span>def <span class="ident">apply_filter</span></span>(<span>self, filter_result: Union[np.ndarray, List[int]]) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generating a new Frame by removing points where filter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_result</code></strong> :&ensp;<code>Union[np.ndarray, List[int]]</code></dt>
<dd>Filter result</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the filter_result has the wrong type</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>rame with filterd rows and reindexed data and points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_filter(self, filter_result: Union[np.ndarray, List[int]]) -&gt; Frame:
    &#34;&#34;&#34;Generating a new Frame by removing points where filter

    Args:
        filter_result (Union[np.ndarray, List[int]]): Filter result

    Raises:
        TypeError: If the filter_result has the wrong type

    Returns:
        Frame: rame with filterd rows and reindexed data and points.
    &#34;&#34;&#34;
    if isinstance(filter_result, np.ndarray):
        # dataframe and pyntcloud based filters
        new_data = self.data.loc[filter_result].reset_index(drop=True)
    elif isinstance(filter_result, list):
        # from open3d filters
        new_data = self.data.iloc[filter_result].reset_index(drop=True)
    else:
        raise TypeError(
            &#34;Wrong filter_result expeciting array with boolean values or list of intices&#34;
        )
    return Frame(new_data, timestamp=self.timestamp)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, name: str, target: Union[None, <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a>, np.ndarray] = None, **kwargs) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate differences and distances to the origin, plane, point and frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>"orgin", "plane", "frame", "point"</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>Union[None, <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a>, np.ndarray]</code>, optional</dt>
<dd>[description]. Defaults to None,</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If name is not supported.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>New frame with added column of the differences</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(
    self, name: str, target: Union[None, Frame, np.ndarray] = None, **kwargs
) -&gt; Frame:
    &#34;&#34;&#34;Calculate differences and distances to the origin, plane, point and frame.

    Args:
        name (str): &#34;orgin&#34;, &#34;plane&#34;, &#34;frame&#34;, &#34;point&#34;
        target (Union[None, Frame, np.ndarray], optional): [description]. Defaults to None,

    Raises:
        ValueError: If name is not supported.

    Returns:
        Frame: New frame with added column of the differences
    &#34;&#34;&#34;
    if name in ALL_DIFFS:
        ALL_DIFFS[name](frame=self, target=target, **kwargs)
        return self
    else:
        raise ValueError(&#34;Unsupported diff. Check docstring&#34;)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, name: str, *args, **kwargs) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, name: str, *args, **kwargs) -&gt; Frame:
    name = name.upper()
    if name in ALL_FILTERS:
        return ALL_FILTERS[name](self, *args, **kwargs)
    else:
        raise ValueError(&#34;Unsupported filter. Check docstring&#34;)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.get_cluster"><code class="name flex">
<span>def <span class="ident">get_cluster</span></span>(<span>self, eps: float, min_points: int) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get the clusters based on open3D cluster_dbscan. Process further with
take_cluster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Density parameter that is used to find neighbouring points.</dd>
<dt><strong><code>min_points</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum number of points to form a cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Dataframe with list of clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process further with
        take_cluster.

    Args:
        eps (float): Density parameter that is used to find neighbouring points.
        min_points (int): Minimum number of points to form a cluster.

    Returns:
        pd.DataFrame: Dataframe with list of clusters.
    &#34;&#34;&#34;
    labels = np.array(
        self.to_instance(&#34;open3d&#34;).cluster_dbscan(
            eps=eps, min_points=min_points, print_progress=False
        )
    )
    labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
    return labels_df</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.limit"><code class="name flex">
<span>def <span class="ident">limit</span></span>(<span>self, dim: "'str'", minvalue: float, maxvalue: float) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Limit the range of certain values in lidar Frame. Can be chained together.</p>
<p>Example:</p>
<p>testframe.limit("x", -1.0, 1.0).limit("intensity", 0.0, 50.0)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>str</code></dt>
<dd>dimension to limit, any column in data not just x, y, or z</dd>
<dt><strong><code>minvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>min value to limit. (greater equal)</dd>
<dt><strong><code>maxvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>max value to limit. (smaller equal)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>limited frame, were columns which did not match the criteria were</dd>
</dl>
<p>dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float) -&gt; Frame:
    &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

    Example:

    testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

    Args:
        dim (str): dimension to limit, any column in data not just x, y, or z
        minvalue (float): min value to limit. (greater equal)
        maxvalue (float): max value to limit. (smaller equal)
    Returns:
        Frame: limited frame, were columns which did not match the criteria were
        dropped.
    &#34;&#34;&#34;
    if maxvalue &lt; minvalue:
        raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
    return self.filter(&#34;value&#34;, dim, &#34;&gt;=&#34;, minvalue).filter(
        &#34;value&#34;, dim, &#34;&lt;=&#34;, maxvalue
    )</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plane_segmentation"><code class="name flex">
<span>def <span class="ident">plane_segmentation</span></span>(<span>self, distance_threshold: float, ransac_n: int, num_iterations: int, return_plane_model: bool = False) ‑> Union[<a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a>, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Segments a plane in the point cloud using the RANSAC algorithm.
Based on open3D plane segmentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>distance_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Max distance a point can be from the plane
model, and still be considered an inlier.</dd>
<dt><strong><code>ransac_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of initial points to be considered inliers in
each iteration.</dd>
<dt><strong><code>num_iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations.</dd>
<dt><strong><code>return_plane_model</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return also plane model parameters.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code> or <code>dict</code></dt>
<dd>Frame with inliers or a dict of Frame with inliers and the</dd>
</dl>
<p>plane parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane_segmentation(
    self,
    distance_threshold: float,
    ransac_n: int,
    num_iterations: int,
    return_plane_model: bool = False,
) -&gt; Union[Frame, dict]:
    &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
    Based on open3D plane segmentation.

    Args:
        distance_threshold (float): Max distance a point can be from the plane
                    model, and still be considered an inlier.
        ransac_n (int):  Number of initial points to be considered inliers in
                    each iteration.
        num_iterations (int): Number of iterations.
        return_plane_model (bool, optional): Return also plane model parameters.
                    Defaults to False.

    Returns:
        Frame or dict: Frame with inliers or a dict of Frame with inliers and the
        plane parameters.
    &#34;&#34;&#34;
    pcd = self.to_instance(&#34;open3d&#34;)
    plane_model, inliers = pcd.segment_plane(
        distance_threshold=distance_threshold,
        ransac_n=ransac_n,
        num_iterations=num_iterations,
    )
    if len(self) &gt; 200:
        warnings.warn(
            &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
            is high. Try to reduce the area of interesst before using
            plane_segmentation. Caused by open3D.&#34;&#34;&#34;
        )
    inlier_Frame = self.apply_filter(inliers)
    if return_plane_model:
        return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
    else:
        return inlier_Frame</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, color: Union[None, str] = None, overlay: dict = {}, point_size: float = 2, prepend_id: str = '', hover_data: List[str] = [], **kwargs) ‑> plotly.graph_objs._figure.Figure</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a Frame as a 3D scatter plot with plotly. It handles plots of single
frames and overlay with other objects, such as other frames from clustering or
planes from plane segmentation.</p>
<p>You can also pass arguments to the plotly express function scatter_3D.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>the frame to plot</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Which column to plot. For example "intensity"</dd>
<dt><strong><code>overlay</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd 1_:="1&quot;:" _Cluster="&quot;Cluster" cluster1_plan1="cluster1,&quot;plan1" plane_model>Dict with of rames to overlay</dd>
<dt><strong><code>point_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Size of each point. Defaults to 2.</dd>
<dt><strong><code>prepend_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>string before point id to display in hover</dd>
</dl>
<p>hover data (list, optional): data columns to display in hover. Default is
all of them.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if the color column name is not in the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Plotly plot</code></dt>
<dd>The interactive plotly plot, best used inside a jupyter</dd>
</dl>
<p>notebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(
    self,
    color: Union[None, str] = None,
    overlay: dict = {},
    point_size: float = 2,
    prepend_id: str = &#34;&#34;,
    hover_data: List[str] = [],
    **kwargs,
) -&gt; plotly.graph_objs._figure.Figure:
    &#34;&#34;&#34;Plot a Frame as a 3D scatter plot with plotly. It handles plots of single
    frames and overlay with other objects, such as other frames from clustering or
    planes from plane segmentation.

    You can also pass arguments to the plotly express function scatter_3D.

    Args:
        frame (Frame): the frame to plot
        color (str or None): Which column to plot. For example &#34;intensity&#34;
        overlay (dict, optional): Dict with of rames to overlay
            {&#34;Cluster 1&#34;: cluster1,&#34;plan1 1&#34;: plane_model}
        point_size (float, optional): Size of each point. Defaults to 2.
        prepend_id (str, optional): string before point id to display in hover
        hover data (list, optional): data columns to display in hover. Default is
            all of them.

    Raises:
        ValueError: if the color column name is not in the data

    Returns:
        Plotly plot: The interactive plotly plot, best used inside a jupyter
        notebook.
    &#34;&#34;&#34;
    if color is not None and color not in self.data.columns:
        raise ValueError(f&#34;choose any of {list(self.data.columns)} or None&#34;)

    ids = [prepend_id + &#34;id=&#34; + str(i) for i in range(0, self.data.shape[0])]

    if hover_data == []:
        hover_data = self.data.columns

    if not all([x in self.data.columns for x in hover_data]):
        raise ValueError(f&#34;choose a list of {list(self.data.columns)} or []&#34;)

    fig = px.scatter_3d(
        self.data,
        x=&#34;x&#34;,
        y=&#34;y&#34;,
        z=&#34;z&#34;,
        color=color,
        hover_name=ids,
        hover_data=hover_data,
        title=self.timestamp_str,
        **kwargs,
    )
    fig.update_traces(
        marker=dict(size=point_size, line=dict(width=0)),
        selector=dict(mode=&#34;markers&#34;),
    )

    if len(overlay) &gt; 0:
        fig = plot_overlay(fig, self, overlay)

    fig.update_layout(
        scene_aspectmode=&#34;data&#34;,
    )
    return fig</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.take_cluster"><code class="name flex">
<span>def <span class="ident">take_cluster</span></span>(<span>self, cluster_number: int, cluster_labels: pd.DataFrame) ‑> <a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Takes only the points belonging to the cluster_number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cluster_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Cluster id to keep.</dd>
<dt><strong><code>cluster_labels</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>clusters generated with get_cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>with cluster of ID cluster_number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame) -&gt; Frame:
    &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

    Args:
        cluster_number (int): Cluster id to keep.
        cluster_labels (pd.DataFrame): clusters generated with get_cluster.

    Returns:
        Frame: with cluster of ID cluster_number.
    &#34;&#34;&#34;
    bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
    return self.apply_filter(bool_array)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, file_path: Path = PosixPath('.'), **kwargs) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the frame as a csv for use with cloud compare or similar tools.
Currently not all attributes of a frame are saved so some information is lost when
using this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>Path</code>, optional</dt>
<dd>Destination. Defaults to the folder of</dd>
</dl>
<p>the bag file and csv with the timestamp of the frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, file_path: Path = Path(), **kwargs) -&gt; None:
    &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
    Currently not all attributes of a frame are saved so some information is lost when
    using this function.

    Args:
        file_path (Path, optional): Destination. Defaults to the folder of
        the bag file and csv with the timestamp of the frame.
    &#34;&#34;&#34;
    ext = file_path.suffix[1:].upper()
    if ext not in FRAME_TO_FILE:
        raise ValueError(
            &#34;Unsupported file format; supported formats are: {}&#34;.format(
                list(FRAME_TO_FILE)
            )
        )

    orig_file_name = Path(self.orig_file).stem
    if file_path == Path():
        # defaulting to csv file
        filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
        destination_folder = Path(self.orig_file).parent.joinpath(filename)
    else:
        destination_folder = file_path

    kwargs[&#34;file_path&#34;] = destination_folder
    kwargs[&#34;frame&#34;] = self

    FRAME_TO_FILE[ext](**kwargs)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.to_instance"><code class="name flex">
<span>def <span class="ident">to_instance</span></span>(<span>self, library: str, **kwargs) ‑> Union[pandas.core.frame.DataFrame, pyntcloud.core_class.PyntCloud, open3d.open3d_pybind.geometry.PointCloud]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert Frame to another librarie instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>library</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the libary</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If libary is not suppored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]</code></dt>
<dd>The derived instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_instance(
    self, library: str, **kwargs
) -&gt; Union[
    pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud
]:
    &#34;&#34;&#34;Convert Frame to another librarie instance.

    Args:
        library (str): name of the libary

    Raises:
        ValueError: If libary is not suppored

    Returns:
        Union[ pd.DataFrame, pyntcloud.PyntCloud, o3d.open3d_pybind.geometry.PointCloud ]: The derived instance
    &#34;&#34;&#34;
    library = library.upper()
    if library not in FRAME_TO_INSTANCE:
        raise ValueError(
            &#34;Unsupported library; supported libraries are: {}&#34;.format(
                list(FRAME_TO_INSTANCE)
            )
        )

    return FRAME_TO_INSTANCE[library](self, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lidar.frame_core.FrameCore" href="frame_core.html#lidar.frame_core.FrameCore">FrameCore</a></b></code>:
<ul class="hlist">
<li><code><a title="lidar.frame_core.FrameCore.data" href="frame_core.html#lidar.frame_core.FrameCore.data">data</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.describe" href="frame_core.html#lidar.frame_core.FrameCore.describe">describe</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.extract_point" href="frame_core.html#lidar.frame_core.FrameCore.extract_point">extract_point</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.has_original_id" href="frame_core.html#lidar.frame_core.FrameCore.has_original_id">has_original_id</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.orig_file" href="frame_core.html#lidar.frame_core.FrameCore.orig_file">orig_file</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.points" href="frame_core.html#lidar.frame_core.FrameCore.points">points</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.timestamp" href="frame_core.html#lidar.frame_core.FrameCore.timestamp">timestamp</a></code></li>
<li><code><a title="lidar.frame_core.FrameCore.timestamp_str" href="frame_core.html#lidar.frame_core.FrameCore.timestamp_str">timestamp_str</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#frame-class">Frame Class.</a><ul>
<li><a href="#developer-notes">Developer notes:</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lidar" href="index.html">lidar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lidar.frame.is_documented_by" href="#lidar.frame.is_documented_by">is_documented_by</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></h4>
<ul class="two-column">
<li><code><a title="lidar.frame.Frame.apply_filter" href="#lidar.frame.Frame.apply_filter">apply_filter</a></code></li>
<li><code><a title="lidar.frame.Frame.diff" href="#lidar.frame.Frame.diff">diff</a></code></li>
<li><code><a title="lidar.frame.Frame.filter" href="#lidar.frame.Frame.filter">filter</a></code></li>
<li><code><a title="lidar.frame.Frame.from_file" href="#lidar.frame.Frame.from_file">from_file</a></code></li>
<li><code><a title="lidar.frame.Frame.from_instance" href="#lidar.frame.Frame.from_instance">from_instance</a></code></li>
<li><code><a title="lidar.frame.Frame.get_cluster" href="#lidar.frame.Frame.get_cluster">get_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.limit" href="#lidar.frame.Frame.limit">limit</a></code></li>
<li><code><a title="lidar.frame.Frame.plane_segmentation" href="#lidar.frame.Frame.plane_segmentation">plane_segmentation</a></code></li>
<li><code><a title="lidar.frame.Frame.plot" href="#lidar.frame.Frame.plot">plot</a></code></li>
<li><code><a title="lidar.frame.Frame.take_cluster" href="#lidar.frame.Frame.take_cluster">take_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.to_file" href="#lidar.frame.Frame.to_file">to_file</a></code></li>
<li><code><a title="lidar.frame.Frame.to_instance" href="#lidar.frame.Frame.to_instance">to_instance</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>